# Разное

- [Почему echo, print, var_dump, print_r не работают?](#echo-bug)
- [Многопоточность, создание потоков и выполнение в фоне.](#multithreading)

---

<a name=echo-bug />

## Почему echo, print, var_dump, print_r не работают?
> Объяснения принципа работы echo в develnext.

Если вы знаете об этих функция, то скорее всего вы знакомы с ними из программирования под веб. Данные функции в develnext работают, но нужно немного разобраться как и почему:

- echo, print и т.п. - не должны выводить текст как сообщение.
- страница в вебе это просто текст, поэтому echo подходит для вывода текста.
- программа в develnext это не просто текст, это сложный набор объектов и логики.

> `echo`, `print`, `var_dump`, `print_r` выводят текст в консоль вывода в диалоге сборки программы.

Если вы писали консольные программы на php, то понимаете, что эти функции выводят текст в `stdout`. UI программа в develnext не исключение и вывод тоже происходит в `stdout`, а не как сообщение.

> Так работает PHP язык изначально, консольная программа это такая же программа как и в DevelNext, программа это не сайт с набором html страничек.

Если вы хотите выводить сообщение, то используйте другие функции, например, `alert()`. Если вы хотите увидеть содержимое переменной в всплывающем окне, то используйте функции `pre()` и `dump()`.

---

<a name=multithreading />

## Многопоточность, создание потоков и выполнение в фоне.

Поток позволяет выполнять ваш код в фоне, параллельно, не загружая основной интерфейс программы. В JPHP есть поддержка потоков изначально, из коробки.

#### Простой вариант

В develnext есть специальный модульный компонент `Скрипт`, который может выполняться в фоне, через метод `callAsync`, т.е. в потоке:

```php
$this->script->callAsync();
```

#### Гибкий вариант

Для потоков есть специальный класс `php\lang\Thread`, рассмотрим пример потока:

```php
$thread = new Thread(function () {
    $i = 0;

    while (true) {
         $i++;
         echo $i, "\n"; // выводим в консоль сборки.

         sleep(2); // паузка в 2 сек.
    }
});

$thread->start(); // стартуем выполнение
```

#### Обращение к UI компонентам из потока

Очень важно понимать, что никаким образом нельзя напрямую взаимодействовать с UI внутри потока, даже показ сообщений относится к UI. У UI есть свой отдельный поток, который отвечает за визуальный интерфейс. Чтобы корректно выполнить код из своего потока в UI потоке, есть функция `uiLater()`:

```php
$this->label->text = 'Поток выполняется...';

$thread = new Thread(function () {
    sleep(3); // ждем 3 сек.

    uiLater(function() {
        $this->label->text = 'Поток выполнен.';
    });
});

$thread->start();
```